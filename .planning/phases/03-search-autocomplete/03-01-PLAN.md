---
phase: 03-search-autocomplete
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useDebounce.ts
  - src/hooks/useSearch.ts
autonomous: true

must_haves:
  truths:
    - "useDebounce hook delays value updates by specified milliseconds"
    - "useSearch hook returns fuzzy-matched results from equipment data"
    - "Search handles typos via Fuse.js threshold configuration"
    - "Search is case-insensitive and trims whitespace"
  artifacts:
    - path: "src/hooks/useDebounce.ts"
      provides: "Generic debounce hook for delaying value updates"
      exports: ["useDebounce"]
    - path: "src/hooks/useSearch.ts"
      provides: "Fuse.js search hook with memoized instance"
      exports: ["useSearch"]
  key_links:
    - from: "src/hooks/useSearch.ts"
      to: "fuse.js"
      via: "import Fuse from 'fuse.js'"
      pattern: "new Fuse"
    - from: "src/hooks/useSearch.ts"
      to: "src/lib/equipment.ts"
      via: "EquipmentEntry type import"
      pattern: "import.*EquipmentEntry"
---

<objective>
Create the search infrastructure hooks: debounce utility and Fuse.js search hook.

Purpose: Establish reusable hooks that encapsulate debouncing and fuzzy search logic, keeping the UI components clean and focused on presentation.

Output: Two Client Component hooks - useDebounce and useSearch - ready for consumption by SearchBar component.
</objective>

<execution_context>
@C:/Users/alexa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/alexa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-search-autocomplete/03-RESEARCH.md

@src/lib/equipment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Fuse.js and create debounce hook</name>
  <files>
    package.json
    src/hooks/useDebounce.ts
  </files>
  <action>
Install Fuse.js dependency:
```bash
npm install fuse.js
```

Create `src/hooks/useDebounce.ts` - a generic debounce hook following standard React pattern:
- Mark with `'use client'` directive (uses useState, useEffect)
- Accept generic type T for value and number for delay
- Use useState to store debounced value
- Use useEffect with setTimeout to update after delay
- Clean up timer on unmount or value/delay change
- Return the debounced value

Implementation follows Pattern 3 from research:
```typescript
'use client';
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
```
  </action>
  <verify>
1. `npm ls fuse.js` shows fuse.js installed
2. File exists at src/hooks/useDebounce.ts
3. TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Fuse.js installed as dependency. useDebounce hook exists with 'use client' directive and correct generic type signature.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Fuse.js search hook</name>
  <files>src/hooks/useSearch.ts</files>
  <action>
Create `src/hooks/useSearch.ts` - wraps Fuse.js with memoized instance:
- Mark with `'use client'` directive
- Import Fuse from 'fuse.js'
- Import EquipmentEntry type from '@/lib/equipment'
- Define Fuse options object:
  - keys: [{name: 'name', weight: 2}, {name: 'aliases', weight: 1.5}, {name: 'manufacturer', weight: 1}, {name: 'slug', weight: 0.5}]
  - threshold: 0.3 (stricter than default 0.6 per research)
  - ignoreLocation: true (match anywhere in string)
  - includeScore: true
  - includeMatches: true (for highlighting)
  - minMatchCharLength: 2
  - shouldSort: true
  - findAllMatches: false (performance)
- Export function useSearch(equipment: EquipmentEntry[], query: string)
- Use useMemo to create Fuse instance, only recreate when equipment changes
- Normalize query: trim whitespace, return empty array if empty
- Call fuse.search with limit: 8
- Return results array (FuseResult<EquipmentEntry>[])

Note on manufacturer field: Only MachineEntry has manufacturer. Fuse.js handles undefined fields gracefully - it simply skips that key for entries without it. TechnologyTermEntry objects will still match on name, aliases, and slug.
  </action>
  <verify>
1. File exists at src/hooks/useSearch.ts
2. TypeScript compiles: `npx tsc --noEmit`
3. Hook exports useSearch function
  </verify>
  <done>
useSearch hook exists with Fuse.js configuration matching research recommendations (threshold 0.3, ignoreLocation true, weighted keys, limit 8).
  </done>
</task>

</tasks>

<verification>
Overall phase 03-01 verification:
1. Both hook files exist in src/hooks/
2. TypeScript compiles without errors: `npx tsc --noEmit`
3. Fuse.js appears in package.json dependencies
</verification>

<success_criteria>
- Fuse.js installed as npm dependency
- useDebounce hook created with generic type support and cleanup
- useSearch hook created with Fuse.js integration and correct configuration
- Both hooks are Client Components ('use client' directive)
- TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-autocomplete/03-01-SUMMARY.md`
</output>
