---
phase: 01-data-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/equipment.ts
  - src/lib/equipment.test.ts
  - src/data/equipment.json
autonomous: true

must_haves:
  truths:
    - "getEquipmentBySlug returns correct entry for valid slug"
    - "getEquipmentBySlug returns undefined for unknown slug"
    - "getEquipmentBySlug resolves aliases to canonical entry"
    - "getAllEquipmentSlugs returns array of all slugs"
    - "Type guards correctly narrow MachineEntry vs TechnologyTermEntry"
  artifacts:
    - path: "src/lib/equipment.ts"
      provides: "Type definitions and lookup utilities"
      exports: ["EquipmentEntry", "MachineEntry", "TechnologyTermEntry", "getEquipmentBySlug", "getAllEquipmentSlugs", "isMachine", "isTechnologyTerm"]
    - path: "src/lib/equipment.test.ts"
      provides: "Test coverage for utility functions"
      contains: "describe.*getEquipmentBySlug"
    - path: "src/data/equipment.json"
      provides: "Seed data for testing (3-5 entries)"
      min_lines: 50
  key_links:
    - from: "src/lib/equipment.ts"
      to: "src/data/equipment.json"
      via: "JSON import"
      pattern: "import.*equipment\.json"
    - from: "src/lib/equipment.ts"
      to: "slugIndex Map"
      via: "alias resolution"
      pattern: "slugIndex\.set.*alias"
---

<objective>
Create TypeScript type definitions for equipment data and TDD-driven utility functions for slug-based lookup.

Purpose: Establish type-safe foundation that all subsequent phases depend on. Types enforce data consistency; utilities provide the API for accessing equipment data.

Output: Working getEquipmentBySlug() and getAllEquipmentSlugs() functions with full test coverage, seed data for testing.
</objective>

<execution_context>
@C:/Users/alexa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/alexa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-CONTEXT.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="tdd">
  <name>Task 1: RED - Create Failing Tests for Equipment Utilities</name>
  <files>src/lib/equipment.test.ts</files>
  <behavior>
    Test cases that must fail initially (functions do not exist yet):

    1. getEquipmentBySlug(gentlemax-pro) returns entry with name GentleMax Pro
    2. getEquipmentBySlug(unknown-machine) returns undefined
    3. getEquipmentBySlug(gentle max pro) resolves alias to canonical entry
    4. getAllEquipmentSlugs() returns array including gentlemax-pro, shr, 755nm
    5. isMachine(machineEntry) returns true, isMachine(techTermEntry) returns false
    6. isTechnologyTerm(techTermEntry) returns true, isTechnologyTerm(machineEntry) returns false
  </behavior>
  <action>
    Create src/lib/equipment.test.ts with Vitest tests covering:
    - getEquipmentBySlug returns correct entry for valid slug
    - getEquipmentBySlug returns undefined for unknown slug
    - getEquipmentBySlug resolves alias to canonical entry
    - getEquipmentBySlug normalizes input to lowercase
    - getAllEquipmentSlugs returns array of all primary slugs
    - getAllEquipmentSlugs does not include aliases
    - isMachine returns true for machine entries, false for tech terms
    - isTechnologyTerm returns true for tech terms, false for machines

    Run tests: npm test - ALL tests must FAIL (module does not exist yet)
  </action>
  <verify>Run npm test - tests fail with Cannot find module or similar import error</verify>
  <done>Test file exists with 8+ test cases, all failing because src/lib/equipment.ts does not exist yet</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN - Implement Types, Seed Data, and Utilities</name>
  <files>src/lib/equipment.ts, src/data/equipment.json</files>
  <behavior>
    Implement minimal code to make all tests pass:

    Type definitions (per CONTEXT.md - NO effectiveness rating):
    - MachineEntry: type, slug, name, manufacturer, technologyType, wavelengths, brandTier, skinTypes, purposeBuilt, coolingMethod, notes, aliases, family, deliveryMethod
    - TechnologyTermEntry: type, slug, name, technologyType, isRealLaser, whatItIs, whyItMatters, askYourClinic, aliases
    - EquipmentEntry: discriminated union

    Seed data (3-5 entries for testing):
    - GentleMax Pro (machine, premium-clinical)
    - SHR (technology-term, delivery-method)
    - 755nm (technology-term, wavelength)
  </behavior>
  <action>
    1. Create src/data/equipment.json with seed data:
       - GentleMax Pro with aliases: [gentle max pro, gentlemaxpro]
       - SHR technology term
       - 755nm wavelength term

    2. Create src/lib/equipment.ts:
       - Define MachineEntry interface (per CONTEXT.md fields)
       - Define TechnologyTermEntry interface
       - Define EquipmentEntry union type
       - Import JSON data with proper typing
       - Build slugIndex Map at module load (mapping both slugs and aliases)
       - Implement getEquipmentBySlug: normalize to lowercase, lookup in slugIndex
       - Implement getAllEquipmentSlugs: return data.map(e => e.slug)
       - Implement isMachine type guard: return entry.type === machine
       - Implement isTechnologyTerm type guard: return entry.type === technology-term

    3. Update tsconfig.json if needed:
       - resolveJsonModule: true
       - esModuleInterop: true

    Run tests: npm test - ALL tests must PASS
  </action>
  <verify>Run npm test - all 8+ tests pass, npx tsc --noEmit compiles clean</verify>
  <done>All tests pass, types compile, seed data validates against type definitions</done>
</task>

<task type="tdd">
  <name>Task 3: REFACTOR - Clean Up and Document</name>
  <files>src/lib/equipment.ts</files>
  <behavior>
    Improve code quality without changing behavior:
    - Add JSDoc comments to all exported functions and types
    - Ensure consistent code style
    - Verify type narrowing works correctly after type guard calls
  </behavior>
  <action>
    1. Add JSDoc comments to getEquipmentBySlug, getAllEquipmentSlugs, isMachine, isTechnologyTerm

    2. Add JSDoc to type definitions explaining the discriminated union pattern

    3. Verify type narrowing works (no TypeScript errors when accessing machine-specific fields after isMachine check)

    4. Run tests: npm test - still PASS
    5. Run TypeScript: npx tsc --noEmit - still clean
  </action>
  <verify>Run npm test (all pass), npx tsc --noEmit (no errors), JSDoc comments visible in IDE hover</verify>
  <done>Code is documented, type narrowing verified, all tests still pass</done>
</task>

</tasks>

<verification>
1. npm test runs equipment tests with all passing
2. TypeScript compiles without errors: npx tsc --noEmit
3. Type narrowing works in test assertions (no type errors when accessing machine-specific fields after isMachine check)
</verification>

<success_criteria>
- All test cases pass (slug lookup, alias resolution, type guards)
- Types correctly narrow when using type guards
- Seed data validates against types (no TypeScript errors)
- Functions are exported and can be imported in other modules
</success_criteria>

<output>
After completion, create .planning/phases/01-data-foundation/01-01-SUMMARY.md
</output>
