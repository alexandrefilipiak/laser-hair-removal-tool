---
phase: 01-data-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/equipment.ts
  - src/lib/equipment.test.ts
  - src/data/equipment.json
autonomous: true

must_haves:
  truths:
    - "getEquipmentBySlug returns correct entry for valid slug"
    - "getEquipmentBySlug returns undefined for unknown slug"
    - "getEquipmentBySlug resolves aliases to canonical entry"
    - "getAllEquipmentSlugs returns array of all slugs"
    - "Type guards correctly narrow MachineEntry vs TechnologyTermEntry"
  artifacts:
    - path: "src/lib/equipment.ts"
      provides: "Type definitions and lookup utilities"
      exports: ["EquipmentEntry", "MachineEntry", "TechnologyTermEntry", "getEquipmentBySlug", "getAllEquipmentSlugs", "isMachine", "isTechnologyTerm"]
    - path: "src/lib/equipment.test.ts"
      provides: "Test coverage for utility functions"
      contains: "describe.*getEquipmentBySlug"
    - path: "src/data/equipment.json"
      provides: "Seed data for testing (3-5 entries)"
      min_lines: 50
  key_links:
    - from: "src/lib/equipment.ts"
      to: "src/data/equipment.json"
      via: "JSON import"
      pattern: "import.*equipment\\.json"
    - from: "src/lib/equipment.ts"
      to: "slugIndex Map"
      via: "alias resolution"
      pattern: "slugIndex\\.set.*alias"
---

<objective>
Create TypeScript type definitions for equipment data and TDD-driven utility functions for slug-based lookup.

Purpose: Establish type-safe foundation that all subsequent phases depend on. Types enforce data consistency; utilities provide the API for accessing equipment data.

Output: Working `getEquipmentBySlug()` and `getAllEquipmentSlugs()` functions with full test coverage, seed data for testing.
</objective>

<execution_context>
@C:/Users/alexa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/alexa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-CONTEXT.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<feature>
  <name>Equipment Type System and Lookup Utilities</name>
  <files>src/lib/equipment.ts, src/lib/equipment.test.ts, src/data/equipment.json</files>
  <behavior>
    Type definitions for discriminated union (MachineEntry | TechnologyTermEntry):

    MachineEntry fields (per CONTEXT.md):
    - type: 'machine' (discriminator)
    - slug: string (unique identifier, lowercase)
    - name: string (display name with proper case)
    - manufacturer: string
    - technologyType: 'laser' | 'ipl' | 'led' | 'rf'
    - wavelengths: string[] (e.g., ["755nm", "1064nm"])
    - brandTier: 'premium-clinical' | 'standard-clinical' | 'consumer' | 'unknown'
    - skinTypes: { fitzpatrickRange: string, displayText: string }
    - purposeBuilt: boolean
    - coolingMethod: string | null
    - notes: string | null
    - aliases: string[] (lowercase variations)
    - family: string | null (e.g., "candela-gentlemax")
    - deliveryMethod: string | null (e.g., "shr" for runtime linking)

    TechnologyTermEntry fields (per CONTEXT.md):
    - type: 'technology-term' (discriminator)
    - slug: string
    - name: string
    - technologyType: 'laser' | 'ipl' | 'led' | 'rf' | 'delivery-method' | 'wavelength'
    - isRealLaser: boolean | null (null for ambiguous like SHR)
    - whatItIs: string (1-2 sentences)
    - whyItMatters: string (variable length)
    - askYourClinic: string | null
    - aliases: string[]

    Utility functions:
    - getEquipmentBySlug(slug: string): EquipmentEntry | undefined
      - Normalizes input to lowercase
      - Returns entry matching slug OR any alias
      - Cases: 'gentlemax-pro' -> entry, 'gentle max pro' -> entry (if alias), 'unknown' -> undefined

    - getAllEquipmentSlugs(): string[]
      - Returns array of all primary slugs (not aliases)
      - Used by Next.js generateStaticParams

    - isMachine(entry: EquipmentEntry): entry is MachineEntry
      - Type guard for filtering

    - isTechnologyTerm(entry: EquipmentEntry): entry is TechnologyTermEntry
      - Type guard for filtering
  </behavior>
  <implementation>
    RED phase:
    1. Create src/lib/equipment.test.ts with tests for:
       - getEquipmentBySlug returns entry for valid slug
       - getEquipmentBySlug returns undefined for unknown slug
       - getEquipmentBySlug resolves alias to canonical entry
       - getAllEquipmentSlugs returns all primary slugs
       - isMachine correctly identifies machine entries
       - isTechnologyTerm correctly identifies technology term entries
    2. Run tests - all should FAIL (functions don't exist)

    GREEN phase:
    1. Create src/data/equipment.json with 3-5 seed entries:
       - 1 premium-clinical laser (GentleMax Pro)
       - 1 technology term (SHR)
       - 1 wavelength term (755nm)
       - Include aliases for testing alias resolution
    2. Create src/lib/equipment.ts with:
       - Type definitions (MachineEntry, TechnologyTermEntry, EquipmentEntry union)
       - Import JSON data
       - Build slug index Map at module load (include aliases)
       - Implement getEquipmentBySlug, getAllEquipmentSlugs
       - Implement type guard functions
    3. Run tests - all should PASS

    REFACTOR phase:
    1. Ensure tsconfig has resolveJsonModule: true, esModuleInterop: true
    2. Add JSDoc comments to exported functions
    3. Run tests - still PASS
  </implementation>
</feature>

<verification>
1. `npm test` runs equipment tests with all passing
2. TypeScript compiles without errors: `npx tsc --noEmit`
3. Type narrowing works in test assertions (no type errors when accessing machine-specific fields after isMachine check)
</verification>

<success_criteria>
- All test cases pass (slug lookup, alias resolution, type guards)
- Types correctly narrow when using type guards
- Seed data validates against types (no TypeScript errors)
- Functions are exported and can be imported in other modules
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
